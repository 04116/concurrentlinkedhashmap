#summary A tutorial for implementing a simple indexing decorator.
#labels Featured

= Introduction =

A [http://java.sun.com/javase/6/docs/api/java/util/Map.html Map] provides the ability to work with key->value pairs and treats each entry independently. A common use-case is that the same value could be retrieved by multiple keys. In most usages the map is unbounded and used for a short duration, so the value can be safely referenced in multiple key->value pairs.

In caches the map is bounded and multiple entries for the same value would impact the size and statistical information. An alternative approach is to store a primaryKey->value mapping in the cache and store the key->primaryKey mapping separately. When the value is added, removed, or evicted the key mapping must be updated accordingly.

== Example ==

An application may retrieve a user's profile by different lookup approaches. The primary usage may be by a unique identifier, while alternative flows may be by the user's email address or login name. In complex applications there may be many alternative lookup approaches based on multiple properties.

|| *Key* || *Property* || *Type* ||
|| id || user.getId() || Primary ||
|| email || user.getEmail() || Secondary ||
|| loginName || user.getLoginName() || Secondary ||

An interesting aspect of the keys is that they are all subsets of the properties on the value (its domain model). In most cases there is a relationship between the key and value rather than an ad hoc grouping. This can be leveraged to allow automatic extraction of the keys from the value.

== Usage ==

The following shows how indexing can be leveraged by a caching facade. The value contains metadata describing the cache information to allow automatic key extraction and association to a cache region. A benefit is that separate key classes are not required, but rather the domain object is treated like a template for retrieving the full value. This can be thought of as a "named lookup" style similar to Hibernate's "named query" approach.

{{{
public class UserProfileService {
    @Autowired
    private Cache cache;

    public User getUserById(long id) {
      User user = new User();
      user.setId(id);
      return cache.get(user, "byId");
    }

    public User getUserByEmail(String email) {
      User user = new User();
      user.setEmail(email);
      return cache.get(user, "byEmail");
    }

    public User getUserByLoginName(String loginName) {
      User user = new User();
      user.setLoginName(loginName);
      return cache.get(user, "byLoginName");
    }

    // etc
}
}}}

= Implementation =

The following shows an implementation of an indexable caching decorator. It uses a data map to store the association from the primaryKey to the value. A secondary map stores a key to the index. An entry is retrieved by using the lookup table to determine the primary key for retrieval from the data map.

== Concurrency ==

The !IndexMap must perform multiple operations when a insertion, update, or removal occurs to keep both mappings in sync. Rather than using a single lock, _lock striping_ can be used as each entry must have a unique set of keys. This allows a high level of concurrency while maintaining correctness by blocking concurrent operations for the same entry.

A traditional _static_ model is adopted by using an array of locks. This approach is performant, but requires a good sizing as independent entry operations may contend due to sharing a lock instance. An alternative _dynamic_ model leverages the garbage collector to acheive per entry locks, but will likely not offer a significant performance improvement in practice.

{{{
/**
 * A reentrant mutual exclusive {@link StripedLock} with a selection algorithm based on the object's identity
 * ({@link #hashCode()} and {@link #equals(Object)} operations).
 * <p>
 * The individual locks supports a maximum of 2147483648 recursive locks by the same thread.
 *
 * @author <a href="mailto:ben.manes@reardencommerce.com">Ben Manes</a>
 */
public final class ReentrantStripedLock extends ForwardingStripedLock {
    private final AbstractReentrantStripedLock delegate;

    /**
     * Creates a {@link StripedLock} using a default number of stripes.
     *
     * @return A reentrant mutual exclusive {@link StripedLock}.
     */
    public static ReentrantStripedLock createFixed() {
        return createFixed(256);
    }

    /**
     * Creates a {@link StripedLock} using the specified number of stripes.
     *
     * @param size The number of locks.
     * @return     A reentrant mutual exclusive {@link StripedLock}.
     */
    public static ReentrantStripedLock createFixed(int size) {
        return new ReentrantStripedLock(new FixedStripedLock(size));
    }

    /**
     * Creates a {@link StripedLock} using a dynamic number of stripes.
     *
     * @return A reentrant mutual exclusive {@link StripedLock}.
     */
    public static ReentrantStripedLock createDynamic() {
        return new ReentrantStripedLock(new DynamicStripedLock());
    }

    /**
     * Creates a reentrant mutual exclusive {@link StripedLock} with the given selection algorithm.
     *
     * @param delegate The lock selection algorithm.
     */
    private ReentrantStripedLock(AbstractReentrantStripedLock delegate) {
        this.delegate = notNull(delegate);
    }

    /**
     * Queries if this lock is held by any thread. This method is designed for use in monitoring of the system
     * state, not for synchronization control.
     *
     * @param o The object to select the lock for.
     * @return  <tt>true</tt> if any thread holds this lock and <tt>false</tt> otherwise.
     * @see     ReentrantLock#isLocked()
     */
    public boolean isLocked(Object o) {
        return delegate().isLocked(o);
    }

    /**
     * Queries if this lock is held by the current thread.
     *
     * @param o The object to select the lock for.
     * @return  <tt>true</tt> if current thread holds this lock and <tt>false</tt> otherwise.
     * @see     ReentrantLock#isHeldByCurrentThread()
     */
    public boolean isHeldByCurrentThread(Object o) {
        return delegate().isHeldByCurrentThread(o);
    }

    /**
     * Queries the number of holds on this lock by the current thread.
     *
     * @param o The object to select the lock for.
     * @return  The number of holds on this lock by the current thread, or zero if this lock is not held
     *          by the current thread.
     * @see     ReentrantLock#getHoldCount()
     */
    public int getHoldCount(Object o) {
        return delegate().getHoldCount(o);
    }

    /**
     * Queries whether any threads are waiting to acquire this lock. Note that because cancellations may occur at any
     * time, a <tt>true</tt> return does not guarantee that any other thread will ever acquire this lock.
     * This method is designed primarily for use in monitoring of the system state.
     *
     * @param o The object to select the lock for.
     * @return  <tt>true</tt> if there may be other threads waiting to acquire the lock.
     * @see     ReentrantLock#hasQueuedThreads()
     */
    public boolean hasQueuedThreads(Object o) {
        return delegate().hasQueuedThreads(o);
    }

    /**
     * Queries whether the given thread is waiting to acquire this lock. Note that because cancellations may occur at
     * any time, a <tt>true</tt> return does not guarantee that this thread will ever acquire this lock.  This method
     * is designed primarily for use in monitoring of the system state.
     *
     * @param o      The object to select the lock for.
     * @param thread The thread,
     * @return       <tt>true</tt> if the given thread is queued waiting for this lock.
     * @see          ReentrantLock#hasQueuedThread(Thread)
     */
    public boolean hasQueuedThread(Object o, Thread thread) {
        return delegate().hasQueuedThread(o, thread);
    }

    /**
     * Returns an estimate of the number of threads waiting to acquire this lock.  The value is only an estimate
     * because the number of threads may change dynamically while this method traverses internal data structures.
     * This method is designed for use in monitoring of the system state, not for synchronization control.
     *
     * @param o The object to select the lock for.
     * @return  The estimated number of threads waiting for this lock
     * @see     ReentrantLock#getQueueLength()
     */
    public int getQueueLength(Object o) {
        return delegate().getQueueLength(o);
    }

    /**
     * Queries whether any threads are waiting on the given condition associated with this lock. Note that because
     * timeouts and interrupts may occur at any time, a <tt>true</tt> return does not guarantee that a future
     * <tt>signal</tt> will awaken any threads.  This method is designed primarily for use in monitoring of
     * the system state.
     *
     * @param o         The object to select the lock for.
     * @param condition The condition
     * @return          <tt>true</tt> if there are any waiting threads.
     * @see             ReentrantLock#hasWaiters(Condition)
     */
    public boolean hasWaiters(Object o, Condition condition) {
        return delegate().hasWaiters(o, condition);
    }

    /**
     * Returns an estimate of the number of threads waiting on the given condition associated with this lock.
     * Note that because timeouts and interrupts may occur at any time, the estimate serves only as an upper
     * bound on the actual number of waiters. This method is designed for use in monitoring of the system
     * state, not for synchronization control.
     *
     * @param o         The object to select the lock for.
     * @param condition The condition.
     * @return          The estimated number of waiting threads.
     * @see             ReentrantLock#getWaitQueueLength(Condition)
     */
    public int getWaitQueueLength(Object o, Condition condition) {
        return delegate().getWaitQueueLength(o, condition);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected AbstractReentrantStripedLock delegate() {
        return delegate;
    }

    /**
     * The base class for a reentrant striped lock selection algorithm.
     */
    private static abstract class AbstractReentrantStripedLock implements StripedLock {

        /**
         * Retrieves the lock instance for the object.
         *
         * @param o The object to select the lock for.
         * @return  The shared lock instance.
         */
        protected abstract ReentrantLock getLock(Object o);

        /**
         * @see ReentrantStripedLock#isLocked(Object)
         */
        public boolean isLocked(Object o) {
            return getLock(o).isLocked();
        }

        /**
         * @see ReentrantStripedLock#isHeldByCurrentThread(Object)
         */
        public boolean isHeldByCurrentThread(Object o) {
            return getLock(o).isHeldByCurrentThread();
        }

        /**
         * @see ReentrantStripedLock#getHoldCount(Object)
         */
        public int getHoldCount(Object o) {
            return getLock(o).getHoldCount();
        }

        /**
         * @see ReentrantStripedLock#hasQueuedThreads(Object)
         */
        public boolean hasQueuedThreads(Object o) {
            return getLock(o).hasQueuedThreads();
        }

        /**
         * @see ReentrantStripedLock#hasQueuedThread(Object, Thread)
         */
       public boolean hasQueuedThread(Object o, Thread thread) {
           return getLock(o).hasQueuedThread(thread);
       }

       /**
        * @see ReentrantStripedLock#getQueueLength(Object)
        */
       public int getQueueLength(Object o) {
           return getLock(o).getQueueLength();
       }

       /**
        * @see ReentrantStripedLock#getWaitQueueLength(Object, Condition)
        */
       public int getWaitQueueLength(Object o, Condition condition) {
           return getLock(o).getWaitQueueLength(condition);
       }

       /**
        * @see ReentrantStripedLock#hasWaiters(Object, Condition)
        */
       public boolean hasWaiters(Object o, Condition condition) {
           return getLock(o).hasWaiters(condition);
       }
    }

    /**
     * Selects the lock based on the object's {@link #hashCode()}. A universal hashing algorithm is applied to
     * improve the spreading across the lock instances.
     */
    private static final class FixedStripedLock extends AbstractReentrantStripedLock {
        private final ReentrantLock[] locks;

        private FixedStripedLock(int size) {
            greaterThan(0, size);
            locks = new ReentrantLock[size];
            for (int i=0; i<size; i++) {
                locks[i] = new ReentrantLock();
            }
        }
        @Override
        protected ReentrantLock getLock(Object o) {
            return locks[abs(hash(notNull(o)) % locks.length)];
        }
        public void lock(Object o) {
            getLock(o).lock();
        }
        public void lockInterruptibly(Object o) throws InterruptedException {
            getLock(o).lockInterruptibly();
        }
        public boolean tryLock(Object o) {
            return getLock(o).tryLock();
        }
        public boolean tryLock(Object o, long time, TimeUnit unit) throws InterruptedException {
            return getLock(o).tryLock(time, unit);
        }
        public void unlock(Object o) {
            getLock(o).unlock();
        }
        public Condition newCondition(Object o) {
            return getLock(o).newCondition();
        }
        @Override
        public String toString() {
            return Arrays.toString(locks);
        }
    }

    /**
     * Selects the lock by associating the object to a unique lock instance. The instances are discarded by a weak
     * reference eviction policy so that mutual exclusion is guaranteed for the duration of the lock's shared usage.
     * If multiple requests for the lock occur, the operations will be performed serially as only one thread can
     * lock the mutex. When no threads reference the lock instance then it is eligible for garbage collection.
     */
    private static final class DynamicStripedLock extends AbstractReentrantStripedLock {
        private final ConcurrentMap<Object, ReentrantLock> locks;
        private final ConcurrentMap<Lock, Integer> references;

        private DynamicStripedLock() {
            references = new ConcurrentHashMap<Lock, Integer>();
            locks = new ReferenceMap<Object, ReentrantLock>(STRONG, WEAK);
        }

        /**
         * Acquires a strong reference to the lock while it is in use.
         *
         * @param lock The shared lock that is being used by this thread.
         */
        private void acquire(ReentrantLock lock) {
            for (;;) {
                Integer current = references.putIfAbsent(lock, 1);
                if ((current == null) || references.replace(lock, current, ++current)) {
                    return; // inserted first use or incremented usage count
                }
            }
        }

        /**
         * Releases a strong reference to the lock. When it is no longer shared, it is eligible for garbage collection.
         *
         * @param lock The shared lock that was previously used by this thread.
         */
        private void release(ReentrantLock lock) {
            for (;;) {
                Integer current = references.get(lock);
                if (current.intValue() == 1) {
                    if (references.remove(lock, current)) {
                        return; // removed only usage of lock
                    }
                    continue; // retry
                } else if (references.replace(lock, current, --current)) {
                    return; // decremented shared usage of lock
                }
            }
        }
        @Override
        protected ReentrantLock getLock(Object o) {
            ReentrantLock lock = new ReentrantLock();
            ReentrantLock current = locks.putIfAbsent(o, lock);
            return (current == null) ? lock : current;
        }
        public void lock(Object o) {
            ReentrantLock lock = getLock(o);
            acquire(lock);
            lock.lock();
        }
        public void lockInterruptibly(Object o) throws InterruptedException {
            ReentrantLock lock = getLock(o);
            acquire(lock);
            lock.lockInterruptibly();
        }
        public boolean tryLock(Object o) {
            ReentrantLock lock = getLock(o);
            if (lock.tryLock()) {
                acquire(lock);
                return true;
            }
            return false;
        }
        public boolean tryLock(Object o, long time, TimeUnit unit) throws InterruptedException {
            ReentrantLock lock = getLock(o);
            if (lock.tryLock(time, unit)) {
                acquire(lock);
                return true;
            }
            return false;
        }
        public void unlock(Object o) {
            ReentrantLock lock = getLock(o);
            lock.unlock();
            release(lock);
        }
        public Condition newCondition(final Object o) {
            return new DynamicCondition(getLock(o));
        }
        @Override
        public boolean hasWaiters(Object o, Condition condition) {
            if (!(condition instanceof DynamicCondition)) {
                throw new IllegalArgumentException("not owner");
            }
            return getLock(o).hasWaiters(((DynamicCondition) condition).condition);
        }
        @Override
        public int getWaitQueueLength(Object o, Condition condition) {
            if (!(condition instanceof DynamicCondition)) {
                throw new IllegalArgumentException("not owner");
            }
            return getLock(o).getWaitQueueLength(((DynamicCondition) condition).condition);
        }
        @Override
        public String toString() {
            return locks.toString();
        }

        /**
         * A condition that while strongly reachable its associated lock is strongly reachable too.
         */
        private static final class DynamicCondition extends ForwardingCondition {
            @SuppressWarnings("unused")
            private final ReentrantLock lock;
            private final Condition condition;

            public DynamicCondition(ReentrantLock lock) {
                this.lock = lock;
                this.condition = lock.newCondition();
            }
            @Override
            protected Condition delegate() {
                return condition;
            }
        }
    }
}
}}}

== !IndexMap ==

When used with a cache as the data store, it is assumed that on an eviction a listener performs a call-back to notify the decorator. With a bit of care, the !SelfPopulatingMap can decorate the !IndexMap.

{{{
package com.reardencommerce.kernel.collections.shared;

import static com.google.common.collect.Iterators.emptyIterator;
import static com.google.common.collect.Maps.immutableEntry;
import static com.reardencommerce.kernel.collections.shared.Maps2.asMap;
import static com.reardencommerce.kernel.collections.shared.Sets2.union;
import static com.reardencommerce.kernel.concurrent.shared.locks.ReentrantStripedLock.createFixed;
import static com.reardencommerce.kernel.utilities.shared.Assertions.isTrue;
import static com.reardencommerce.kernel.utilities.shared.Assertions.notNull;
import static java.util.Collections.unmodifiableCollection;
import static java.util.Collections.unmodifiableSet;

import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import com.google.common.base.Function;
import com.google.common.collect.ImmutableSet;
import com.reardencommerce.kernel.concurrent.shared.locks.StripedLock;

/**
 * A {@link ConcurrentMap} where multiple keys index to the same value and removal of the value causes the removal
 * of all of its associated keys. When a value is added it can be retrieved by using any of the applicable keys.
 * It is assumed that keys-value mappings do not overlap. All operations that update associations in the map and
 * accept both a key and a value parameter will assert that the given key is a valid association.
 * <p>
 * This implementation provides a different definition of {@link #size()}, which reflects the number of values rather
 * than the number of key-value pairs. The collections retrieved from {@link #keySet()}, {@link #values()}, and
 * {@link #entrySet()} are not naturally aligned as they reflect different aspects of the data structure.
 * <p>
 * The entries in this map must conform to the following restrictions.
 * <ul>
 *   <li> The key-value mappings may not overlap.
 *   <li> The primary key cannot change over the lifetime of the value.
 *   <li> The secondary keys may change over the lifetime of the value.
 * </ul>
 *
 * @author <a href="mailto:ben.manes@reardencommerce.com">Ben Manes</a>
 */
public class IndexMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {
    private final ConcurrentMap<K, Index<K>> indexes;
    private final Function<V, Index<K>> extractor;
    private final ConcurrentMap<K, V> store;
    private final StripedLock lock;

    /**
     * An {@link IndexMap} backed by a {@link ConcurrentHashMap}.
     *
     * @param extractor Extracts the keys that are associated with the given value.
     */
    public static <K, V> IndexMap<K, V> create(Function<V, Index<K>> extractor) {
        return create(new ConcurrentHashMap<K, V>(), extractor);
    }

    /**
     * An {@link IndexMap} backed by the specified map.
     *
     * @param store     The backing data map to decorate.
     * @param extractor Extracts the keys that are associated with the given value.
     */
    public static <K, V> IndexMap<K, V> create(ConcurrentMap<K, V> store, Function<V, Index<K>> extractor) {
        return create(store, new ConcurrentHashMap<K, Index<K>>(), extractor);
    }

    /**
     * An {@link IndexMap} backed by the specified maps.
     *
     * @param store     The backing data map to decorate.
     * @param indexes   The backing key index map to decorate.
     * @param extractor Extracts the keys that are associated with the given value.
     */
    public static <K, V> IndexMap<K, V> create(ConcurrentMap<K, V> store, ConcurrentMap<K, Index<K>> indexes,
                                               Function<V, Index<K>> extractor) {
        return new IndexMap<K, V>(store, indexes, extractor);
    }

    /**
     * An implementation backed by the specified map.
     *
     * @param store     The backing data map to decorate.
     * @param indexes   The backing key index map to decorate.
     * @param extractor Extracts the keys that are associated with the given value.
     */
    protected IndexMap(ConcurrentMap<K, V> store, ConcurrentMap<K, Index<K>> indexes, Function<V, Index<K>> extractor) {
        this.extractor = notNull(extractor);
        this.indexes = notNull(indexes);
        this.store = notNull(store);
        this.lock = createFixed();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean containsKey(Object key) {
        return indexes.containsKey(key);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean containsValue(Object value) {
        return store.containsValue(value);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isEmpty() {
        return store.isEmpty();
    }

    /**
     * Retrieves the number of values in the map, rather than the number of key-value pairs. The size reflects the true
     * size of the store and the number of keys can be retrieved inexpensively through the {@link #keySet()} method.
     *
     * @return The number of values in the map.
     */
    @Override
    public int size() {
        return store.size();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void clear() {
        for (K key : store.keySet()) {
            remove(key);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public V get(Object key) {
        Index<K> index = indexes.get(key);
        return (index == null) ? null : store.get(index.getPrimary());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public V put(K key, V value) {
        Index<K> index = checkIndex(key, value);
        return put(index, value);
    }

    /**
     * Places the value into the map and associates its keys.
     *
     * @param value The value to put into the map.
     * @return      The previous value, or <tt>null</tt> if there was no mapping.
     */
    public V putValue(V value) {
        notNull(value);
        Index<K> index = extractor.apply(value);
        return put(index, value);
    }

    /**
     * Places the value into the map and associates its keys.
     *
     * @param index The key associations.
     * @param value The value to put into the map.
     * @return      The previous value, or <tt>null</tt> if there was no mapping.
     */
    private V put(Index<K> index, V value) {
        lock.lock(index.getPrimary());
        try {
            V old = store.put(index.getPrimary(), value);
            if (old == null) {
                addIndex(index);
            } else {
                updateIndex(extractor.apply(old), index);
            }
            return old;
        } finally {
            lock.unlock(index.getPrimary());
        }
    }

    /**
     * {@inheritDoc}
     */
    public V putIfAbsent(K key, V value) {
        notNull(key);
        Index<K> index = checkIndex(key, value);
        return putIfAbsent(index, value);
    }

    /**
     * Places the value into the map if absent and associates its keys.
     *
     * @param value The value to put into the map.
     * @return      The previous value, or <tt>null</tt> if there was no mapping.
     */
    public V putIfAbsentValue(V value) {
        notNull(value);
        Index<K> index = extractor.apply(value);
        return putIfAbsent(index, value);
    }

    /**
     * Places the value into the map if absent and associates its keys.
     *
     * @param index The key associations.
     * @param value The value to put into the map.
     * @return      The previous value, or <tt>null</tt> if there was no mapping.
     */
    private V putIfAbsent(Index<K> index, V value) {
        K primary = index.getPrimary();
        lock.lock(primary);
        try {
            V old = store.putIfAbsent(index.getPrimary(), value);
            if (old == null) {
                addIndex(index);
            }
            return old;
        } finally {
            lock.unlock(primary);
        }
    }

    /**
     * {@inheritDoc}
     */
    public V replace(K key, V value) {
        notNull(key);
        Index<K> index = checkIndex(key, value);
        return replace(index, value);
    }

    /**
     * Replaces the entry based on the primary key only if it is currently mapped to some value.
     *
     * @param value The value to put into the map.
     * @return      The previous value, or <tt>null</tt> if there was no mapping.
     */
    public V replaceValue(V value) {
        notNull(value);
        Index<K> index = extractor.apply(value);
        return replace(index, value);
    }

    /**
     * Replaces the entry based on the primary key only if it is currently mapped to some value.
     *
     * @param index The key associations.
     * @param value The value to put into the map.
     * @return      The previous value, or <tt>null</tt> if there was no mapping.
     */
    private V replace(Index<K> index, V value) {
        K primary = index.getPrimary();
        lock.lock(primary);
        try {
            V old = store.replace(primary, value);
            if (old != null) {
                updateIndex(indexes.get(primary), index);
            }
            return old;
        } finally {
            lock.unlock(primary);
        }
    }

    /**
     * {@inheritDoc}
     */
    public boolean replace(K key, V oldValue, V newValue) {
        notNull(key);
        Index<K> index = checkIndex(key, oldValue);
        return replace(index, oldValue, newValue);
    }

    /**
     * Replaces the entry based on the primary key only if it is currently mapped to the given value.
     *
     * @param oldValue The expected value in the map.
     * @param newValue The value to put into the map.
     * @return         The previous value, or <tt>null</tt> if there was no mapping.
     */
    public boolean replaceValue(V oldValue, V newValue) {
        notNull(oldValue);
        notNull(newValue);
        Index<K> oldIndex = extractor.apply(oldValue);
        return replace(oldIndex, oldValue, newValue);
    }

    /**
     * Replaces the entry based on the primary key only if it is currently mapped to the given value.
     *
     * @param oldIndex The old key associations.
     * @param oldValue The expected value in the map.
     * @param newValue The value to put into the map.
     * @return         The previous value, or <tt>null</tt> if there was no mapping.
     */
    public boolean replace(Index<K> oldIndex, V oldValue, V newValue) {
        K primary = oldIndex.getPrimary();
        lock.lock(primary);
        try {
            if (store.replace(primary, oldValue, newValue)) {
                updateIndex(oldIndex, extractor.apply(newValue));
                return true;
            }
            return false;
        } finally {
            lock.unlock(primary);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public V remove(Object key) {
        notNull(key);
        Index<K> index = indexes.get(key);
        if (index == null) {
            return null;
        }
        K primary = index.getPrimary();
        lock.lock(primary);
        try {
            // if the store is bounded then the value may be evicted and a call-back performed to cleanup
            // the index keys. Therefore remove them if found, regardless of whether the value still exists
            V value = store.remove(primary);
            index = indexes.get(primary);
            if (index != null) {
                removeIndex(index);
            }
            return value;
        } finally {
            lock.unlock(primary);
        }
    }

    /**
     * {@inheritDoc}
     */
    public boolean remove(Object key, Object value) {
        Index<K> index = indexes.get(key);
        if (index == null) {
            return false;
        }
        K primary = index.getPrimary();
        lock.lock(primary);
        try {
            if (store.remove(primary, value)) {
                removeIndex(indexes.get(primary));
                return true;
            }
            return false;
        } finally {
            lock.unlock(primary);
        }
    }

    /**
     * Removes the value and its associates keys from the map.
     *
     * @param value The value to remove from the map.
     * @return      Whether the value was found and removed.
     */
    public boolean removeValue(V value) {
        Index<K> index = extractor.apply(value);
        return remove(index.getPrimary(), value);
    }

    /**
     * Extracts the index from the value and asserts that the given key is a valid association.
     *
     * @param key   The key.
     * @param value The value.
     * @return      The index.
     */
    private Index<K> checkIndex(K key, V value) {
        notNull(key);
        notNull(value);
        Index<K> index = extractor.apply(value);
        return isTrue(index.getAll().contains(key), index, "Invalid association: %s not in %s", key, index);
    }

    /**
     * Adds the indexed keys.
     */
    protected void addIndex(Index<K> index) {
        indexes.putAll(asMap(index.getAll(), index));
    }

    /**
     * Removes the indexed keys.
     */
    protected void removeIndex(Index<K> index) {
        for (K key : index.getAll()) {
            indexes.remove(key);
        }
    }

    /**
     * Updates the index associations for a replaced value. It is expected that the primary key does not change,
     * but that secondary key associations may have become stale. If so, the stale indexes are removed and the
     * new indexes added to the mapping.
     */
    protected void updateIndex(Index<K> oldIndex, Index<K> newIndex) {
        // Removes the stale keys that no longer map to the old index
        Set<K> removed = new HashSet<K>(oldIndex.getSecondaries());
        removed.removeAll(newIndex.getSecondaries());
        for (K key : removed) {
            indexes.remove(key);
        }

        // Adds the new keys, or updates old ones, to map to the new index
        addIndex(newIndex);
    }

    /**
     * Retrieves the backing map of the keys to their primary.
     *
     * @return The key-primary mapping.
     */
    protected ConcurrentMap<K, Index<K>> keyDelegate() {
        return indexes;
    }

    /**
     * Retrieves the backing map of the primary key to the value.
     *
     * @return The primary-value mapping.
     */
    protected ConcurrentMap<K, V> valueDelegate() {
        return store;
    }

    /**
     * Retrieves the function that extracts the keys from a value.
     *
     * @return The key generating function.
     */
    public Function<V, Index<K>> extractor() {
        return extractor;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set<K> keySet() {
        return unmodifiableSet(indexes.keySet());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Collection<V> values() {
        return unmodifiableCollection(store.values());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set<Entry<K, V>> entrySet() {
        return new EntrySet();
    }

    /**
     * The index associated with a value.
     *
     * @author <a href="mailto:ben.manes@reardencommerce.com">Ben Manes</a>
     */
    public static final class Index<K> {
        private final K primary;
        private final Set<K> secondaries;

        /**
         * The index keys associated with a single value.
         *
         * @param primary   The primary key to the value.
         * @param secondaries The secondary keys to the value.
         */
        public Index(K primary, K... secondaries) {
            this(primary, ImmutableSet.of(secondaries));
        }

        /**
         * The index keys associated with a single value.
         *
         * @param primary   The primary key to the value.
         * @param secondary The secondary keys to the value.
         */
        public Index(K primary, Set<K> secondaries) {
            this.primary = notNull(primary);
            this.secondaries = unmodifiableSet(secondaries);
        }

        /**
         * Retrieves the primary key.
         */
        public K getPrimary() {
            return primary;
        }

        /**
         * Retrieves the secondary keys to index with.
         */
        public Set<K> getSecondaries() {
            return secondaries;
        }

        /**
         * Retrieves all of the keys.
         */
        public Set<K> getAll() {
            return union(getPrimary(), getSecondaries());
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
            return getAll().toString();
        }
    }

    /**
     * An adapter that represents the association of multiple keys to a single value.
     */
    private final class EntrySet extends AbstractSet<Entry<K, V>> {
        @Override
        public void clear() {
            IndexMap.this.clear();
        }
        @Override
        public int size() {
            return IndexMap.this.size();
        }
        @Override
        public Iterator<Entry<K, V>> iterator() {
            return new EntryIterator(values().iterator());
        }
        @Override
        public boolean contains(Object obj) {
            if (!(obj instanceof Entry)) {
                return false;
            }
            Entry<?, ?> entry = (Entry<?, ?>) obj;
            V value = get(entry.getKey());
            return (value != null) && (value.equals(entry.getValue()));
        }
        @Override
        public boolean add(Entry<K, V> entry) {
            return (putIfAbsent(entry.getKey(), entry.getValue()) == null);
        }
        @Override
        public boolean remove(Object obj) {
            if (!(obj instanceof Entry)) {
                return false;
            }
            Entry<?, ?> entry = (Entry<?, ?>) obj;
            return IndexMap.this.remove(entry.getKey(), entry.getValue());
        }
        @Override
        public Object[] toArray() {
            // avoids indexes for concurrent collections
            Collection<Entry<K, V>> entries = new ArrayList<Entry<K, V>>(size());
            for (Entry<K, V> entry : this) {
                entries.add(entry);
            }
            return entries.toArray();
        }
        @Override
        public <T> T[] toArray(T[] array) {
            // avoids indexes for concurrent collections
            Collection<Entry<K, V>> entries = new ArrayList<Entry<K, V>>(size());
            for (Entry<K, V> entry : this) {
                entries.add(entry);
            }
            return entries.toArray(array);
        }
    }

    /**
     * An adapter that represents the association of multiple keys to a single value.
     */
    private final class EntryIterator implements Iterator<Entry<K, V>> {
        private final Iterator<V> values;
        private Iterator<K> keys;
        private V value;

        public EntryIterator(Iterator<V> values) {
            this.keys = emptyIterator();
            this.values = values;
        }
        public boolean hasNext() {
            return keys.hasNext() || values.hasNext();
        }
        public Entry<K, V> next() {
            if (!keys.hasNext()) {
                value = values.next();
                Index<K> index = extractor.apply(value);
                keys = index.getAll().iterator();
            }
            return immutableEntry(keys.next(), value);
        }
        public void remove() {
            IndexMap.this.removeValue(value);
        }
    }
}
}}}