#summary The algorithmic design of a concurrent linked hash map.

----
*UNDER CONSTRUCTION*
----

= Introduction =
The following describes the algorithm for a concurrent [http://java.sun.com/javase/6/docs/api/java/util/LinkedHashMap.html LinkedHashMap]. This algorithm builds on the concepts outlined in [Design], which describes a functional concurrent algorithm using per-node locking. This algorithm removes the explicit locking by introducing _compare-and-swap_ operations. This was done by making the following observations:

 * An *insertion* can be reduced from 2 to 1 blocking instruction by introducing a CAS loop.
  # The new element's _previous_ is eagerly set to the existing tail's auxiliary (the sentinel's _previous_).
  # The sentinel's _previous_ is set to the new element's _auxiliary_ if and only if it was the existing tail. Repeat at (1) until this succeeds.
  # Set the previous tail's _auxiliary's next_ to the new element.
 * A *removal* must introduce a CAS loop if the adjacent element is being linked by the above *insertion* algorithm. It is modified by repeatedly attempting to set the next element's _previous_ to the removed element's _previous_, if it equalled the removed element's _auxiliary_.
 * If the above is done, then auxiliaries are only beneficial for removals. They can be removed by introducing further CAS operations.

----
== Empty ==
When the hash table is empty the sentinel element is linked to itself.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/spin/empty.png]
----
== Steady-State ==
When all of the transients have died away the structure looks like the following if there are three entries.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/spin/steady-state.png]
----
== Retrieval ==
In an LRU policy when an entry is successfully retrieved from the hash table it is moved to the tail of the list.

 # Retrieve from hash table
 # If found, try to remove the element
   * If successful,
     * Insert to the tail of the list
   * If unsuccessful, continue
     * A concurrent removal is unlinking it
     * A concurrent insertion or retrieval for the same element is linking it
 # If found, return the value held by the element. Otherwise null.
----
== Update ==
An update corresponds to the _put_ and _replace_ operations on a [http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html ConcurrentMap].

 # Perform map operation to retrieve the element
   * If _put_, this is a _putIfAbsent_ with the element found
   * If _replace_, this is a _get_ with the element found
 # E->value = new_value
   * This may be conditional on a _replace(key, oldValue, newValue)_
 # Perform _retrieval_ step #2.

----
== Insertion ==
The following shows the algorithm for inserting an entry. This corresponds to the _putIfAbsent_ and _put_ operations on a [http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html ConcurrentMap]. The _put_ operation performs either an update or insertion based on the state of the map, so it is emulated though usage of the _putIfAbsent_ operation.

 # Insert E_new into hash table
   * If unsuccessful, return current item
 # E_new->prev = S->prev
 # E_new->prev->next = E_new iff (E_new->prev->next == S)
   * If unsuccessful, repeat at (2).
 # S->prev = E_new iff (S->prev == E_new->prev)
   * If unsuccessful and (S->prev != E_new), repeat at (4)
 # E_new->next = S

=== Insert E1 ===
The following shows the insertion of {K1, E1} into an empty map.

==== Insert ====
Insert the entry into hash table. Perform steps #1.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/spin/insert_E1_1.png]

==== Insert and Lock Tail ====
Insert the entry into hash table and obtain the tail's lock. Perform steps #4 - #5.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_2.png]

==== Link Tail ====
Update the tail link. Perform step #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_3.png]

==== Link E1 ====
Insert E1 into list. Perform steps #7 - #8.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_4.png]

==== Unlock ====
Unlock. Perform steps #9 - #10.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_5.png]

=== Insert E2 ===
The following shows the insertion of {K2, E2} into the above map.

==== Create Bundle ====
Create the bundle, acquire the element's lock, and set it up for linking. Perform steps #1 - #3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_1.png]

==== Insert and Lock Tail ====
Insert the entry into hash table and obtain the tail's lock. Perform steps #4 - #5.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_2.png]

==== Link Tail ====
Update the tail link. Perform step #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_3.png]

==== Link E2 ====
Insert E2 into list. Perform steps #7 - #8.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_4.png]

==== Unlock ====
Unlock. Perform steps #9 - #10.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_5.png]

----
== Removal ==
The following shows the algorithm for removing an entry.

 # Remove entry from hash table
   * If not found, return
 # Lock E_old
 # Lock E_old->bwd (aux)
 # Lock aux->fwd (aux_next)
 # E_next->bwd = aux
 # aux->fwd = E_next
 # Unlock aux

If E_next is being concurrently linked or removed it will be blocked attempting to retrieve the shared auxiliary's lock. While that operation is waiting its element's back pointer can be updated. When the auxiliary is unlocked the concurrent operation will obtain the lock and perform its task with the list in a valid state. As the removed element and auxiliary nodes are no longer referenced they do not need to be unlocked.

=== Remove And Lock ===
Remove {K2, E2} from the hash table and obtain locks. Perform steps #1 - #4.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_1.png]

=== Unlink ===
Remove E2 from the list. Perform steps #5 - #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_2.png]

=== Unlock ===
Unlock. Perform step #7.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_3.png]