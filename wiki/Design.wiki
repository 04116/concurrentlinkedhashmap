#summary The algorithmic design of a lock-free linked hash map.
#labels Phase-Design,Featured

= Introduction =
The following describes the algorithm for a concurrent [http://java.sun.com/javase/6/docs/api/java/util/LinkedHashMap.html LinkedHashMap]. Please note that at this time it has not been fully implemented, but is the end goal.

== Buffers ==
The usage of buffers between elements is a key design choice. When removing an element from the middle of the list, two separate atomic operations must be performed (updating _prev->next_ or _next->prev_). As atomic operations are not composable, if concurrent removals of sequential elements occurs then the links can become corrupt. The immediate solutions are to fix links by a backtracking algorithm (error-prone), lock all three nodes, or mark the node as 'dead' and allow it to be removed by the eviction policy. The latter, while simple and safe, consumes a slot in the cache and can be modeled as an eviction queue.

The buffers strategy allows for isolating each element so that operations on one does not affect another. Each element owns one side of a shared buffer and is guaranteed that no concurrent operations will be performed. The element can be safely removed and the extra buffer removed by _swinging_ its neighbor's previous pointer across it.

*NOTE:* Renamed to _auxilary_ nodes to correspond with John Valois' 1996 paper "Lock-Free Linked Lists Using Compare-and-Swap". This paper was found after rediscoving the same technique and, for consistance, his terminology has been adopted.

== Elements ==
An element is the {key, value} pair, plus any additional information that is useful for the eviction algorithm (e.g. frequency).

== Hash Table ==
The hash table allows for O(1) access to a cached entry. The table associates the key to an element, which is linked in the list. This can be thought of as cursor into the list data structure, allowing manipulations in O(1) efficiency.

== Cache ==
The capacity is specified by the client and the size is the number of elements linked on the list. The size field is updated on each insertion or removal from the list. After an element is inserted into the list the state is evaluated to determine whether the cache has overflowed (size > capacity) and, if so, an eviction is triggered. Each eviction policy determines the ordering of elements on the list such that the victim is at the head. The head will either point to the victim element or, if it is empty, the tail. Once an element is found it can be removed using the standard operation. If unsuccessful due to concurrent usage, an eviction will be retried until a success condition is met.

----
= NEW DESIGN: 3/2-linked List =

The list is tentitively being called a 3/2-linked list. It supports O(1) operations with a forward iterator. Unlike a doubly-linked list, it does not support reverse iteration.

== Why not a singly-linked list? ==
In a singly-linked list using auxilary nodes, the hash table's value would be the auxilary node. A removal is performed by traversing the auxilary node to its corresponding element and unlinking it by setting the auxilary->next to element->next. However, this leaves the element's auxilary node on the list. It cannot be removed as an unknown element points to it, so rather the next element's auxilary node must be discarded.

The extra auxilary node can be removed by setting the removed element's auxilary node to the next element. By using the key, the hash table's entry is updated to no longer reference the discarded auxilary node. As this requires a segment lock, it is undesirable for caches that must remove elements frequently (e.g. LRU).

== Why not a doubly-linked list? ==
In a doubly-linked list using auxilary nodes, the hash table's value is the element. A removal must lock the element and a neighbor (either always left or always right, based on design). The element and its auxilary nodes can then be unlinked from the list and discarded.

The flaw with this design is the unnecessary complexity. In serial usage, the ordering may be desirable for iteration such as by an insertion policy. In concurrent usage, the ordering should not be useful or relied upon. The faster unordered iteration from the hash table's entries is a better practice. This means that reverse iteration will not be exposed and the 3/2-linked list provides a faster alternative.

----
== Empty ==

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/empty.png]
----
== Steady-State ==

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/steady-state.png]
----
== Retrieval ==
In an LRU policy, when an entry is successfully retrieved from the hash table it is moved to the tail of the list. 

 # Retrieve from map
 # If found, try to acquire the element's lock
   * If successful, remove and reinsert to tail
   * If unsuccessful, continue
     * A concurrent insert or retrievel for the same element is linking it
     * A concurrent removal is unlinking it
 # If found, return the value held by the element. Otherwise null

----
== Insertion ==
The following shows the algorithm for inserting an entry. This corresponds to the _putIfAbsent_ operation on a [http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html ConcurrentMap].

 # E_new->fwd = aux
 # aux->fwd = S
 # Lock E_new
 # Insert E_new into hash table
   * If unsuccessful, return current item
 # Lock S->back
 # Lock E_new->fwd
 # S->back->aux_fwd = E_new
 # E_new->back = S->back
 # S->back = E_new->fwd
 # Unlock E_new->back
 # Unload S->back
 # Unlock E_new

=== Insert E1 ===
The following shows the insertion of {K1, E1} into an empty map.

==== Create Bundle ====
Create the bundle and set it up for linking. Perform steps #1 - #3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_1.png]

==== Insert and Lock ====
Insert entry into hash table and obtain locks. Perform steps #4 - #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_2.png]

==== Link E1 ====
Insert E1 into list. Perform steps #7 - #9.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_3.png]

==== Unlock ====
Unlock. Perform steps #10 - #12.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_4.png]

=== Insert E2 ===
The following shows the insertion of {K2, E2} into the above map.

==== Create Bundle ====
Create the bundle and set it up for linking. Perform steps #1 - #3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_1.png]

==== Insert and Lock ====
Insert entry into hash table and obtain locks. Perform steps #4 - #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_2.png]

==== Link E2 ====
Insert E2 into list. Perform steps #7 - #9.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_3.png]

==== Unlock ====
Unlock. Perform steps #10 - #12.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_4.png]

----
== Removal ==
The following shows the algorithm for removing an entry.

 # Remove entry from hash table
   * If not found, return
 # Lock E_old
 # Lock E_old->bwd (aux)
 # Lock aux->fwd (aux_next)
 # E_next->bwd = aux
 # aux->fwd = E_next
 # Unlock aux

If E_next is being concurrently linked or removed it will be blocked attempting to retrieve the shared auxilary's lock. While that operation is waiting, its element's back pointer can be updated. When the auxilary is unlocked, the concurrent operation will obtain its lock and perform its task with a valid state of the list. As the removed element and auxilary nodes are no longer referenced, they do not need to be unlocked.

=== Remove And Lock ===
Remove {K2, E2} from the hash table and obtain locks. Perform steps #1 - #4.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_1.png]

=== Unlink ===
Remove E2 from the list. Perform steps #5 - #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_2.png]

=== Unlock ===
Unlock. Perform steps #7.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_3.png]

----

= INITIAL DESIGN: Doubly-linked List =
The following shows the very first, initial design after thinking of the buffer approach. It does not go into every detail to cover race concerns, as it is a little too high-level as I flushed out the details. It assumes element locks are used, but doesn't indicate it in the diagrams.

----

== Empty ==
When the map is empty, the head and tail sentinel nodes are linked together. The sentinel nodes are buffers that can never be removed.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/empty.png]

----

== Steady State ==
When all of the transients have died away, the structure would look like the following if there were three entries.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/steady-state.png]

----
== Insertion ==
An element may be added to the beginning, middle, or end. The algorithm is agnostic to where the bundle is being placed.

 # Add to map
 # Create bundle
 # Swing element's _prev->next_ pointer to element
 # Set buffer's _next->prev_ pointer to buffer
 # Increment the size and check if eviction is necessary

==== First Element ====
Adding {K1, E1} to an empty list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/insert-singleton.png]

==== Append Element ====
Adding {K2, E2} to the end of the list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/insert-last.png]

==== Prepend Element ====
Adding {K3, E3} to the beginning of the list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/insert-first.png]

==== Within List ====
Adding {K4, E4} to be between E1 and E3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/insert-middle.png]

----

== Removal ==
An element may be removed from the beginning, middle, or end of the list. The algorithm is agnostic to where the bundle was located.

=== Approach #1 ===
Buffers provide isolation which allows the element to be unlinked safely. This results in two buffers in sequence.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/two-step-removal-1.png]

By properly swinging the references, the extra buffer can be removed.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/two-step-removal-2.png]

=== Approach #2 ===
The ability to remove bundles in one pass needs a little more thought. Approach #1 is safe and, at times, looks composable and therefore an optimization is to perform it in one step. This is probably a fallacy, but its always good to explore every option.

 # Remove from map
 # Decrement the size
 # Swing buffer's _next->prev_ to element's _prev_
 # Set element's _prev->next_ to buffer's _prev_

==== Only Element ====
Removing {K1, E1} from singleton list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/remove-singleton.png]

==== First Element ====
Removing {K1, E1} from beginning of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/remove-first.png]

==== Last Element ====
Removing {K2, E2} from end of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/remove-last.png]

==== Within List ====
Removing {K2, E2} from middle of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/doubly-linked/remove-middle.png]