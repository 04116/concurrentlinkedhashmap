#summary The algorithmic design of a lock-free linked hash map.
#labels Phase-Design,Featured

= Introduction =
The following describes the algorithm for a concurrent [http://java.sun.com/javase/6/docs/api/java/util/LinkedHashMap.html LinkedHashMap]. Please note that at this time it has not been fully implemented, but is the end goal.

== Buffers ==
The usage of buffers between elements is a key design choice. When removing an element from the middle of the list, two separate atomic operations must be performed (updating _prev->next_ or _next->prev_). As atomic operations are not composable, if concurrent removals of sequential elements occurs then the links can become corrupt. The immediate solutions are to fix links by a backtracking algorithm (error-prone), lock all three nodes, or mark the node as 'dead' and allow it to be removed by the eviction policy. The latter, while simple and safe, consumes a slot in the cache and can be modeled as an eviction queue.

The buffers strategy allows for isolating each element so that operations on one does not affect another. Each element owns one side of a shared buffer and is guaranteed that no concurrent operations will be performed. The element can be safely removed and the extra buffer removed by _swinging_ its neighbor's previous pointer across it.

== Elements ==
An element is the {key, value} pair, plus any additional information that is useful for the eviction algorithm (e.g. frequency).

== Hash Table ==
The hash table allows for O(1) access to a cached entry. The table associates the key to an element, which is linked in the list. This can be thought of as cursor into the list data structure, allowing manipulations in O(1) efficiency.

== Cache ==
The capacity is specified by the client and the size is the number of elements linked on the list. The size field is updated on each insertion or removal from the list. After an element is inserted into the list the state is evaluated to determine whether the cache has overflowed (size > capacity) and, if so, an eviction is triggered. Each eviction policy determines the ordering of elements on the list such that the victim is at the head. The head will either point to the victim element or, if it is empty, the tail. Once an element is found it can be removed using the standard operation. If unsuccessful due to concurrent usage, an eviction will be retried until a success condition is met.

----

= Empty =
When the map is empty, the head and tail sentinel nodes are linked together. The sentinel nodes are buffers that can never be removed.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/empty.png]

----

= Steady State =
When all of the transients have died away, the structure would look like the following if there were three entries.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/steady-state.png]

----
= Insertion =
An element may be added to the beginning, middle, or end. The algorithm is agnostic to where the bundle is being placed.

 # Add to map
 # Create bundle
 # Swing element's _prev->next_ pointer to element
 # Set buffer's _next->prev_ pointer to buffer
 # Increment the size and check if eviction is necessary

=== First Element ===
Adding {K1, E1} to an empty list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-singleton.png]

=== Append Element ===
Adding {K2, E2} to the end of the list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-last.png]

=== Prepend Element ===
Adding {K3, E3} to the beginning of the list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-first.png]

=== Within List ===
Adding {K4, E4} to be between E1 and E3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-middle.png]

----

= Removal =
An element may be removed from the beginning, middle, or end of the list. The algorithm is agnostic to where the bundle was located.

== Approach #1 ==
Buffers provide isolation which allows the element to be unlinked safely. This results in two buffers in sequence.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/two-step-removal-1.png]

By properly swinging the references, the extra buffer can be removed.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/two-step-removal-2.png]

== Approach #2 ==
The ability to remove bundles in one pass needs a little more thought. Approach #1 is safe and, at times, looks composable and therefore an optimization is to perform it in one step. This is probably a fallacy, but its always good to explore every option.

 # Remove from map
 # Decrement the size
 # Swing buffer's _next->prev_ to element's _prev_
 # Set element's _prev->next_ to buffer's _prev_

=== Only Element ===
Removing {K1, E1} from singleton list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-singleton.png]

=== First Element ===
Removing {K1, E1} from beginning of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-first.png]

=== Last Element ===
Removing {K2, E2} from end of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-last.png]

=== Within List ===
Removing {K2, E2} from middle of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-middle.png]