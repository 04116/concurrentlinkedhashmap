#summary The algorithmic design of a lock-free linked hash map.
#labels Phase-Design,Featured

= Introduction =
The following describes the algorithm for a concurrent [http://java.sun.com/javase/6/docs/api/java/util/LinkedHashMap.html LinkedHashMap]. Please note that at this time it has not been fully implemented, but is the end goal.

== Hash Table ==
The hash table allows for O(1) access to a cached entry. The table associates the key to an element, which is linked in the list. This can be thought of as cursor into the list data structure, allowing manipulations in O(1) efficiency.

== Elements ==
An element is the {key, value} pair, plus any additional information that is useful for the eviction algorithm (e.g. frequency).

== Auxilaries ==
In a normal LRU cache, a doubly-linked list cross-custs the hash table. When a removal is performed, the two adjacent elements must be updated to unlink the victim element. If a global lock is not used, this structure causes a problem as it requires two atomic operations to be performed. As _compare and swap_ operations are not composable, the race conditions of concurrent operations must be handled.

The usage of auxilary nodes between each element helps to isolate them and allows and not require composibility of atomic operations. This simplifies the per-node locking to avoid deadlock scenarios and allows operations to work with two elements rather than three.

This technique was originally discovered by John Valois in his 1996 paper [http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.9506 Lock-Free Linked Lists Using Compare-and-Swap]. This paper discusses a lock-free singly-linked list and attempts to adapt the idea to tree structures. In our usage, the idea was rediscovered but for consistancy his terminology is used (ours was "buffers").

== Eviction ==
This data structure supports insertion- and access order-bassed eviction policies. Each policy determines the ordering of the list so that the victim element is at the beginning.

When an element is added to the list, its size field is incremented. If the size exceeds the cache's capacity, then an eviction will be triggered. The first element will be traversed to and a removal will be attempted. This will repeat until either the removal succeeds, a concurrent removal has shrunk the size to be below the threshold, or no element was found (empty list).

----
= 1-1/2 linked list =

The list is tentitively being called a "one and a half linked list". It supports O(1) operations with a forward iterator. Unlike a doubly-linked list it does not support reverse iteration.

== Why not a singly-linked list? ==
In a singly-linked list using auxilary nodes, the hash table's would curse to the auxilary node. A removal is performed by traversing the auxilary node to its corresponding element and unlinking it by setting the auxilary->next to element->next. However, this leaves the element's auxilary node on the list. It cannot be removed as an unknown element points to it, so rather the next element's auxilary node must be discarded.

The extra auxilary node can be removed by setting the removed element's auxilary node to the next element. By using the key, the hash table's entry is updated to no longer reference the discarded auxilary node. As this requires a segment lock, it is undesirable for caches that must remove elements frequently (e.g. LRU).

== Why not a doubly-linked list? ==
In a doubly-linked list using auxilary nodes, the hash table's curses to the element. A removal must lock the element and a neighbor (either always left or always right). The element and its auxilary nodes can then be unlinked from the list and discarded. 

The flaw with this design is that it adds unnecessary complexity. In serial usage, the ordering may be desirable for iteration such as by displaying all elements by their insertion order. In concurrent usage, the ordering should not be useful or relied upon. The faster unordered iteration from the hash table's entries can be relied upon instead. This observation means that neither forward or reverse iteration of the list is a desirable feature.

----
== Empty ==

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/empty.png]
----
== Steady-State ==

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/steady-state.png]
----
== Retrieval ==
In an LRU policy, when an entry is successfully retrieved from the hash table it is moved to the tail of the list. 

 # Retrieve from hash table
 # If found, try to acquire the element's lock
   * If successful, remove and reinsert to tail
   * If unsuccessful, continue
     * A concurrent insert or retrievel for the same element is linking it
     * A concurrent removal is unlinking it
 # If found, return the value held by the element. Otherwise null
----
== Update ==
An update to an entry does not require changing the data structure. This corresponds to the _put_ and _replace_ operations on a [http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html ConcurrentMap].

 # Perform map operation to retrieve element
   * If _put_, this is a _putIfAbsent_ with the element found
   * If _replace_, this is a _get_ with the element found
 # E->value = new_value
   * This may be conditional on a _replace(key, oldValue, newValue)_

----
== Insertion ==
The following shows the algorithm for inserting an entry. This corresponds to the _putIfAbsent_ and _put_ operations on a [http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html ConcurrentMap]. The _put_ operation performs either an update or insertion based on the state of the map, so it is emulated though usage of the _putIfAbsent_ operation.

 # E_new->fwd = aux
 # aux->fwd = S
 # Lock E_new
 # Insert E_new into hash table
   * If unsuccessful, return current item
 # Lock S->back
 # Lock E_new->fwd
 # S->back->aux_fwd = E_new
 # E_new->back = S->back
 # S->back = E_new->fwd
 # Unlock E_new->back
 # Unload S->back
 # Unlock E_new

=== Insert E1 ===
The following shows the insertion of {K1, E1} into an empty map.

==== Create Bundle ====
Create the bundle and set it up for linking. Perform steps #1 - #3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_1.png]

==== Insert and Lock ====
Insert entry into hash table and obtain locks. Perform steps #4 - #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_2.png]

==== Link E1 ====
Insert E1 into list. Perform steps #7 - #9.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_3.png]

==== Unlock ====
Unlock. Perform steps #10 - #12.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E1_4.png]

=== Insert E2 ===
The following shows the insertion of {K2, E2} into the above map.

==== Create Bundle ====
Create the bundle and set it up for linking. Perform steps #1 - #3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_1.png]

==== Insert and Lock ====
Insert entry into hash table and obtain locks. Perform steps #4 - #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_2.png]

==== Link E2 ====
Insert E2 into list. Perform steps #7 - #9.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_3.png]

==== Unlock ====
Unlock. Perform steps #10 - #12.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/insert_E2_4.png]

----
== Removal ==
The following shows the algorithm for removing an entry.

 # Remove entry from hash table
   * If not found, return
 # Lock E_old
 # Lock E_old->bwd (aux)
 # Lock aux->fwd (aux_next)
 # E_next->bwd = aux
 # aux->fwd = E_next
 # Unlock aux

If E_next is being concurrently linked or removed it will be blocked attempting to retrieve the shared auxilary's lock. While that operation is waiting, its element's back pointer can be updated. When the auxilary is unlocked, the concurrent operation will obtain its lock and perform its task with a valid state of the list. As the removed element and auxilary nodes are no longer referenced, they do not need to be unlocked.

=== Remove And Lock ===
Remove {K2, E2} from the hash table and obtain locks. Perform steps #1 - #4.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_1.png]

=== Unlink ===
Remove E2 from the list. Perform steps #5 - #6.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_2.png]

=== Unlock ===
Unlock. Perform steps #7.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/1.5-linked/remove_E2_3.png]