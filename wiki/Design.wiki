#summary The algorithmic design of a lock-free linked hash map.
#labels Phase-Design,Featured

= Introduction =
The following describes the algorithm for a concurrent [http://java.sun.com/javase/6/docs/api/java/util/LinkedHashMap.html LinkedHashMap]. Please note that at this time it has not been fully implemented, but is the end goal.

== Buffers ==
The usage of buffers between elements is a key design choice. When removing an element from the middle of the list, two seperate atomic operations must be preformed (update prev->next, next->prev). As atomic operations are not composable, if concurrent removals of sequential elements occurs then the links can become corrupt. The immediate solutions are to fix links by a backtracking algorithm (error-prone), lock all three nodes, or mark the node as 'dead' and allow it to be removed by the eviction policy. The latter, while simple and safe, consumes a slot in the cache and can be modeled as an eviction queue.

The buffers strategy allows for isolating each element so that operations on one does not affect another. Each element owns one side of a shared buffer and is guaranteed that no concurrent operations will be performed. The element can be safely removed and the extra buffer removed by _swinging_ its neighbor's previous pointer across it.

== Elements ==
An element is the {key, value} pair, plus any additional information that is useful for the eviction algorithm (e.g. frequency).

== Hash Table ==
The hash table allows for O(1) access to a cached entry. The table associates the key to an element, which is linked in the list. This can be thought of as cursor into the list data structure, allowing manipulations in O(1) efficiency.

== Cache ==
The capacity is specified by the client and the size is the number of elements linked on the list. The size field is updated on each insertion or removal from the list. After an element is inserted into the list the state is evaluated to determine whether the cache has overflowed (size > capacity) and, if so, an eviction is triggered.

----

= Empty =
When the map is empty, the head and tail sentinel nodes are linked together. The sentinel nodes are buffers that can never be removed.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/empty.png]

----

= Steady State =
When all of the transients have died away, the structure would look like the following if there were three entries.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/steady-state.png]

----
= Insertion =
An element may be added to the begining, end, middle. The algorithm is agnostic to where the bundle is being placed.

 # Add to map
 # Create bundle
 # Swing element's _prev->next_ pointer
 # Swing buffer's _next->prev_ pointer, and backtrack if changed
 # Increment the size and check if eviction is necessary

=== First ===
Adding {K1, E1} to an empty list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-singleton.png]

=== Append ===
Adding {K2, E2} to the end of the list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-last.png]

=== Prepend ===
Adding {K3, E3} to the begining of the list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-first.png]

=== Within ===
Adding {K4, E4} to the between E1 and E3.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/insert-middle.png]

----

= Removal =
An element may be removed from the begining, end, or middle of the list. The algorithm is agnostic to where the bundle was located.

 # Remove from map
 # Decrement the size
 # Swing buffer's _next->prev_ to element's _prev_
 # Set element's _prev->next_ to buffer's _prev_

=== Only ===
Removing {K1, E1} from singleton list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-singleton.png]

=== First ===
Removing {K1, E1} from begining of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-first.png]

=== Last ===
Removing {K2, E2} from end of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-last.png]

=== Last ===
Removing {K2, E2} from middle of list.

[http://concurrentlinkedhashmap.googlecode.com/svn/wiki/images/design/remove-middle.png]

----
= Eviction =
Each eviction policy determines the ordering of elements on the list such that the victim is at the head. The head will either point to the victim element, if it is empty, the tail. Once an element is found, it can be removed using the standard operation. If unsuccessful due to concurrent usage, the process will try until a success condition is met.