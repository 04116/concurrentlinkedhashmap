#summary A tutorial for implementing a simple caching decorator.
#labels Featured

= Introduction =

The [http://java.sun.com/javase/6/docs/api/java/util/concurrent/package-summary.html java.util.concurrent] package makes it easy to implement the [http://en.wikipedia.org/wiki/Memoization Memoization] idiom - a function that remembers the results of the input. The examples discussed here are further described in [http://jcip.net/ Java Concurrency in Practice].

= Single-item Memoization =

A [http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/Future.html Future] provides a promise of the results of a computation that may be performed on some thread. It will block the _get()_ call until the result is available.

{{{
public class Example {
  private final FutureTask<Computation> future = new FutureTask<Computation>(new Computable());

  // Lazily computes the work and returns the value
  public Computation getComputation() throws Exception {
    future.run(); // no-ops on all subsequent calls
    return future.get();
  }

  private static final class Computable implements Callable<Computation> {
    public Computation call() {
      // do work, return
    }
  }
}
}}}

= Multi-item Memoization =

By using a Map multiple items can be lazily loaded. If unbounded this provides a configuration pool, while if bounded and self-evicting this provides a convenient cache.

{{{
public class SelfPopulatingMap<K, V> implements Map<K, V> {
  private final ConcurrentMap<K, Future<V>> map;
  private final EntryFactory<K, V> factory;

  public SelfPopulatingMap(ConcurrentMap<K, Future<V>> map, EntryFactory<K, V> factory) {
    this.map = map;
    this.factory = factory;
  }

  // Retrieves the value, creating it if needed.
  public V get(final K key) {
    FutureTask<V> task = new FutureTask<V>(
      new Callable<V>() {
        public V call() throws Exception {
          return factory.createEntry(key);
        }
      });
    Future<V> future = map.putIfAbsent(key, task);
    try {
      if (future == null) {
        future = task;
        task.run();
      }
      return future.get();
    } catch (Exception e) {
      remove(key);
      throw new RuntimeException(e);
    }
  }

  public static interface EntryFactory<K, V> {
    V createEntry(K key) throws Exception;
  }

  // further implementation details for a Map<K, V>
}
}}}

= A Multi-item Memoization Implementation =
The following shows a production-quality implementation, but to avoid introducing bugs it does not generalize out custom utilities. In addition to the single retrieval approach described above, it extends the concept to support bulk retrieval.

{{{
package com.rc.collections;

import static com.rc.collections.Maps2.forEach;
import static com.rc.collections.Maps2.subMap;
import static com.rc.collections.functions.Functions2.asFunction2ByValue;
import static com.rc.collections.functions.Functions2.asMapEntryFunction;
import static com.rc.util.Assertions.notNull;
import static com.rc.util.concurrent.Futures.asFuture;
import static com.rc.util.concurrent.Futures.fromFuture;
import static com.rc.util.concurrent.Futures.fromFutures;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

import com.google.common.base.Function;
import com.rc.collections.functions.Function2;
import com.rc.collections.transforming.TransformingConcurrentMap;
import com.rc.collections.transforming.TransformingSet;

/**
 * A {@link ConcurrentMap} that automatically creates an entry when not found and blocks other callers for that entry
 * during its creation process. Provides added optimizations if a bulk creation process is specified.
 * <p>
 * This implementation is not fully type-safe due to the inability to inspect the necessary type information at runtime.
 * For methods using raw object parameters, such as {@link #get(Object)}, a {@link ClassCastException} will be thrown
 * rather than returning a negative result on an invalid parameter type. This can be resolved by decorating with the
 * {@link com.rc.collections.Maps2#checkedConcurrentMap(Map, Class, Class)}.
 *
 * @author <a href="mailto:ben.manes@reardencommerce.com">Ben Manes</a>
 * @see <tt>Java Concurrency in Practice</tt>'s Memoizer example.
 */
public class SelfPopulatingMap<K, V> extends TransformingConcurrentMap<K, Future<V>, V> {
    private static final Function2<?, ?, ?> decoder = asFunction2ByValue(fromFuture());
    private static final Function2<?, ?, ?> encoder = asFunction2ByValue(asFuture());
    private final ConcurrentMap<K, Future<V>> delegate;
    private final Loader<K, V> loader;

    /**
     * An unbounded implementation using a {@link ConcurrentHashMap}.
     *
     * @param factory The factory for creating entries.
     */
    public SelfPopulatingMap(EntryFactory<K, V> factory) {
        this(new ConcurrentHashMap<K, Future<V>>(), factory);
    }

    /**
     * An implementation that decorates the specified map.
     *
     * @param map     The backing map to decorate.
     * @param factory The factory for creating entries.
     */
    public SelfPopulatingMap(ConcurrentMap<K, Future<V>> map, EntryFactory<K, V> factory) {
        this.delegate = notNull(map);
        this.loader = (factory instanceof BulkEntryFactory)
                            ? new ParallelLoader((BulkEntryFactory<K, V>) factory)
                            : new SerialLoader(factory);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean containsValue(Object value) {
        notNull(value);

        // Handles the lack of equals() being implemented by futures
        for (Future<V> future : delegate().values()) {
            try {
                if (future.isDone() && value.equals(future.get())) {
                    return true;
                }
            } catch (Exception e) {
                // ignore
            }
        }
        return false;
    }

    /**
     * Peeks into the backing map and retrieves the value if it exists.
     *
     * @param key The key whose associated value may be returned.
     * @return    The value or <tt>null</tt> if not found.
     */
    public V peek(Object key) {
        Future<V> future = delegate().get(key);
        return (future != null) && future.isDone()
                    ? fromFuture(future)
                    : null;
    }

    /**
     * Peeks into the backing map and retrieves the values for the given keys.
     *
     * @param keys The keys whose associated values may be returned.
     * @return     The entries for the specified keys.
     */
    public Map<K, V> peekAll(Collection<? extends K> keys) {
        return forEach(keys, new Function<K, V>() {
            public V apply(K key) {
                return peek(key);
            }
        });
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @SuppressWarnings("unchecked")
    public V get(Object key) {
        notNull(key);
        return loader.get((K) key);
    }

    /**
     * Retrieves a mapping of the given keys to their corresponding value.
     *
     * @param keys The keys whose associated values are to be returned.
     * @return     The entries for the specified keys.
     */
    public Map<K, V> getAll(Collection<? extends K> keys) {
        notNull(keys);
        return loader.getAll(keys);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean remove(Object key, Object value) {
        notNull(key, "Null key");
        notNull(value, "Null value");

        // Handles the lack of equals() being implemented by futures
        Future<V> current = delegate().get(key);
        return (current != null) && fromFuture(current).equals(value)
                    ? delegate().remove(key, current) // instance equals
                    : false;
    }

    /**
     * Removes the mapping for the keys if present.
     *
     * @param keys The keys for the entries to remove.
     */
    public void removeAll(Collection<? extends K> keys) {
        notNull(keys);
        for (K key : keys) {
            delegate().remove(key);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean replace(K key, V oldValue, V newValue) {
        notNull(key, "Null key");
        notNull(oldValue, "Null old value");
        notNull(newValue, "Null new value");

        // Handles the lack of equals() being implemented by futures
        Future<V> current = delegate().get(key);
        return (current != null) && oldValue.equals(fromFuture(current))
                    ? delegate().replace(key, current, asFuture(newValue))
                    : false;
    }

    /**
     * Refreshes the entry by creating a new value and swapping it with the old value.
     * If a failure occurs then the previous entry will be removed.
     *
     * @param key The key.
     */
    public void refresh(K key) {
        try {
            V oldValue = peek(key);
            if (oldValue == null) {
                return;
            }

            V newValue = loader.createEntry(key);
            if (newValue == null) {
                delegate().remove(key);
            } else {
                replace(key, oldValue, newValue);
            }
        } catch (Exception e) {
            delegate().remove(key);
            throw new RuntimeException(e);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set<Entry<K, V>> entrySet() {
        return new EntrySet();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @SuppressWarnings("unchecked")
    protected final Function2<K, V, Future<V>> encoder() {
        return (Function2<K, V, Future<V>>) encoder;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @SuppressWarnings("unchecked")
    protected final Function2<K, Future<V>, V> decoder() {
        return (Function2<K, Future<V>, V>) decoder;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected final ConcurrentMap<K, Future<V>> delegate() {
        return delegate;
    }

    /**
     * A factory for creating a single entry.
     */
    public interface EntryFactory<K, V> {

        /**
         * Creates the entry for the map.
         *
         * @param key The key.
         * @return    The value.
         */
        V createEntry(K key) throws Exception;
    }

    /**
     * A factory with an optimized bulk creation strategy.
     */
    public interface BulkEntryFactory<K, V> extends EntryFactory<K, V> {

        /**
         * Creates entries for the map.
         *
         * @param keys The keys.
         * @return     The entries.
         */
        Map<K, V> createEntries(Collection<K> keys) throws Exception;
    }

    /**
     * Provides the retrieval strategy for the backing map. If the value is not found
     * it will be created and added back to the map.
     */
    private interface Loader<K, V> extends EntryFactory<K, V> {
        /**
         * Retrieves the value, creating it if necessary, and adds it to the map.
         */
        V get(K key);

        /**
         * Retrieves the values, creating them if necessary, and adds them to the map.
         */
        Map<K, V> getAll(Collection<? extends K> keys);
    }

    /**
     * A loader that is optimized for a serial creation.
     */
    private class SerialLoader implements Loader<K, V> {
        private final EntryFactory<K, V> factory;

        public SerialLoader(EntryFactory<K, V> factory) {
            this.factory = notNull(factory);
        }
        public V createEntry(K key) throws Exception {
            return factory.createEntry(key);
        }
        public V get(final K key) {
            FutureTask<V> task = new FutureTask<V>(
                    new Callable<V>() {
                        public V call() throws Exception {
                            return factory.createEntry(key);
                        }
                    });
            Future<V> future = delegate().putIfAbsent(key, task);
            if (future == null) {
                future = task;
                task.run();
            }
            try {
                V value = fromFuture(future);
                if (value == null) {
                    delegate().remove(key, future);
                }
                return value;
            } catch (RuntimeException e) {
                delegate().remove(key, future);
                throw e;
            }
        }
        public Map<K, V> getAll(Collection<? extends K> keys) {
            return subMap(keys, SelfPopulatingMap.this);
        }
    }

    /**
     * A loader that is optimized for parallel creation. For the values being created, all
     * subsequent calls for those keys are blocked while the bulk operation is being performed.
     */
    private final class ParallelLoader extends SerialLoader {
        private final BulkEntryFactory<K, V> factory;

        public ParallelLoader(BulkEntryFactory<K, V> factory) {
            super(factory);
            this.factory = notNull(factory);
        }
        @Override
        public Map<K, V> getAll(Collection<? extends K> keys) {
            // Sets up a bulk operation to be performed for the keys that are not found
            final Collection<K> creationKeys = new ArrayList<K>(keys.size());
            final FutureTask<Map<K, V>> task = new FutureTask<Map<K, V>>(
                    new Callable<Map<K, V>>() {
                        public Map<K, V> call() throws Exception {
                            return creationKeys.isEmpty() ? Collections.<K, V>emptyMap()
                                                          : factory.createEntries(creationKeys);
                        }
                    });

            // For any key not found, adds a proxy for retrieval once the the bulk operation
            // has completed. Also composes a map of all keys to their value holder.
            List<FutureTask<V>> proxies = new ArrayList<FutureTask<V>>(keys.size());
            Map<K, Future<V>> results = new HashMap<K, Future<V>>(keys.size());
            for (K key : keys) {
                FutureTask<V> proxy = new FutureTask<V>(new Proxy(key, task));
                Future<V> future = delegate().putIfAbsent(key, proxy);
                if (future == null) {
                    future = proxy;
                    proxies.add(proxy);
                    creationKeys.add(key);
                }
                results.put(key, future);
            }

            // Executes the bulk operation and runs the proxies so that they are warmed with their value
            task.run();
            for (FutureTask<V> proxy : proxies) {
                proxy.run();
            }

            // Extracts the values from the holders and returns the mapping
            return fromFutures(results);
        }
    }

    /**
     * A single-item proxy to the results of a bulk operation.
     */
    private final class Proxy implements Callable<V> {
        private Future<Map<K, V>> task;
        private K key;

        public Proxy(K key, Future<Map<K, V>> task) {
            this.task = task;
            this.key = key;
        }
        public V call() throws Exception {
            try {
                V value = task.get().get(key);
                if (value == null) {
                    delegate().remove(key);
                }
                return value;
            } catch (Exception e) {
                delegate().remove(key);
                throw e;
            } finally {
                // allows GC
                task = null;
                key = null;
            }
        }
    }

    /**
     * An adapter to represent the data in the external type.
     */
    private final class EntrySet extends TransformingSet<Entry<K, Future<V>>, Entry<K, V>> {
        @Override
        public boolean contains(Object obj) {
            if (!(obj instanceof Entry)) {
                return false;
            }
            Entry<?, ?> entry = (Entry<?, ?>) obj;
            V value = peek(entry.getKey()); // non-blocking
            return (value != null) && (value.equals(entry.getValue()));
        }
        @Override
        public boolean add(Entry<K, V> entry) {
            return (putIfAbsent(entry.getKey(), entry.getValue()) == null);
        }
        @Override
        protected Set<Entry<K, Future<V>>> delegate() {
            return SelfPopulatingMap.this.delegate().entrySet();
        }
        @Override
        protected Function<Entry<K, V>, Entry<K, Future<V>>> encoder() {
            return asMapEntryFunction(SelfPopulatingMap.this.encoder());
        }
        @Override
        protected Function<Entry<K, Future<V>>, Entry<K, V>> decoder() {
            return asMapEntryFunction(SelfPopulatingMap.this.decoder());
        }
    }
}
}}}
{{{
import static com.rc.collections.Collections3.combine;
import static com.rc.collections.Maps2.forEach;
import static java.lang.Integer.valueOf;
import static java.util.Arrays.asList;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertFalse;
import static org.testng.Assert.assertNull;
import static org.testng.Assert.assertTrue;
import static org.testng.Assert.fail;

import java.util.Collection;
import java.util.List;
import java.util.Map;

import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import com.google.common.base.Function;
import com.rc.collections.SelfPopulatingMap.BulkEntryFactory;

/**
 * A unit test for the {@link SelfPopulatingMap}.
 *
 * @author <a href="mailto:ben.manes@reardencommerce.com">Ben Manes</a>
 */
public final class SelfPopulatingMapTest {
    private final IdentityFactory<Integer> factory = new IdentityFactory<Integer>();
    private final SelfPopulatingMap<Integer, Integer> map = new SelfPopulatingMap<Integer, Integer>(factory);

    @BeforeMethod
    public void reset() {
        map.clear();
        factory.count = 0;
        factory.fail = false;
    }

    @Test
    public void clearSizeIsEmpty() {
        map.put(1, 1);
        assertFalse(map.isEmpty());
        assertEquals(map.size(), 1);

        map.clear();
        assertNull(map.peek(1));
        assertTrue(map.isEmpty());
        assertEquals(map.size(), 0);
    }

    @Test
    public void singular() {
        assertNull(map.peek(1));
        assertFalse(map.containsKey(1));
        assertFalse(map.containsValue(1));
        assertEquals(map.get(1), valueOf(1));
        assertEquals(map.put(1, 2), valueOf(1));
        assertEquals(map.get(1), valueOf(2));
        assertEquals(map.putIfAbsent(1, 3), valueOf(2));
        assertEquals(map.replace(1, 3), valueOf(2));
        assertEquals(map.remove(1), valueOf(3));
        assertNull(map.replace(1, 4));
        assertNull(map.putIfAbsent(1, 4));
        assertEquals(map.get(1), valueOf(4));
        assertEquals(map.peek(1), valueOf(4));
        assertTrue(map.containsKey(1));
        assertTrue(map.containsValue(4));
        assertFalse(map.replace(1, 3, 5));
        assertTrue(map.replace(1, 4, 5));
        assertFalse(map.remove(1, 6));
        assertTrue(map.remove(1, 5));
    }

    @Test
    public void refresh() {
        map.refresh(1);
        assertFalse(map.containsKey(1));
        assertNull(map.put(1, 5));
        map.refresh(1);
        assertEquals(map.peek(1), valueOf(1));
    }

    @Test
    public void bulk() {
        List<Integer> keys = asList(1, 2, 3, 4, 5);
        Map<Integer, Integer> entries = map.getAll(keys);
        assertTrue(entries.keySet().containsAll(keys));
        assertTrue(entries.values().containsAll(keys));
        assertEquals(entries.size(), keys.size());
        assertEquals(factory.count, keys.size());

        int count = factory.count;
        assertEquals(map.getAll(keys), entries);
        assertEquals(factory.count, count);
        assertEquals(map.peekAll(combine(keys, asList(6, 7, 8))), entries);

        map.removeAll(keys);
        assertTrue(map.isEmpty());

        map.putAll(entries);
        assertEquals(map, entries);

        assertTrue(map.keySet().containsAll(keys));
        assertTrue(map.values().containsAll(keys));
    }

    @Test
    public void failure() {
        factory.fail = true;

        // singular
        try {
            assertNull(map.get(1));
            fail("Expected an exception to be thrown");
        } catch (RuntimeException e) {
            assertNull(map.peek(1));
        }

        // bulk
        try {
            assertTrue(map.getAll(asList(1, 2, 3, 4)).isEmpty());
            fail("Expected an exception to be thrown");
        } catch (RuntimeException e) {
            assertTrue(map.peekAll(asList(1, 2, 3, 4)).isEmpty());
        }
    }

    private static final class IdentityFactory<K> implements BulkEntryFactory<K, K> {
        public boolean fail;
        public int count;

        public K createEntry(K key) {
            checkForFailure();
            count++;
            return key;
        }
        public Map<K, K> createEntries(Collection<K> keys) {
            checkForFailure();
            return forEach(keys, new Function<K, K>() {
                public K apply(K key) {
                    return createEntry(key);
                }
            });
        }
        private void checkForFailure() {
            if (fail) {
                throw new RuntimeException();
            }
        }
    }
}
}}}